# Inter-Process Communication

## Overview
1. **Sync send, sync receive**: sender is blocked when the message is sent, receiver will continue whether or not a message is received (uncommon)
2. **Approaches to accomplish IPC** (4): **file system**; **message passing**; **netwoking communication**; **pipes and shared memory**

## File System
1. producer and consumer processes communicate through files in the file system; the system is responsible for file creation and manipulation (e.g. managing permissions)

## Message passing
1. **Message passing using signals**: signals are an interrupt with a specified ID and no messages
```c
/* both functions return 0 when successful and -1 when failed */
/* pid options: 
   (1) > 0   sends to pid; 
   (2) == 0  sends to all processes in the same process group
   (3) == -1 sends to all processes if permission allows (except init and the calling process)
   (4) < -1  sends to all processes with process group ID |pid|
*/
int kill( int pid, int signo );
/* send signal to the current process */
int raise( int signo );
```
2. **Null signal** can be invoked using `kill` with 0 argument for the signal. It checks if the recipient process exists. (Limitations: (1) the process might exit between the null signal and the time you do something with it (2) process IDs are relatively unique, so a given ID could be used for a difference process)
3. A signal is generated by a process and later delivered to its recipient. During the time between, the signal is **pending**.
4. **Blocking signals**: a process can refuse to listen any signals except `SIGKILL` and `SIGSTOP`. Blocking signals is supposed to be temporary.
```c
/* how: SIG_BLOCK; SIG_UNBLOCK; SIG_SETMASK */
int sigprocmask( int how, const sigset_t * set, sigset_t * old_set );

int sigemptyset( sigset_t *set ); /* Initialize an empty sigset_t */
int sigaddset( sigset_t *set, int signal ); /* Add specified signal to set */
int sigfillset( sigset_t *set ); /* Add ALL signals to set */
int sigdelset( sigset_t *set, int signal ); /* Remove specified signal from set */
int sigismember( sigset_t *set, int signal ); /* Returns 1 if true, 0 if false */

sigset_t set;
sigset_t previous;
sigemptyset( &set ); /* Initialize set */
sigaddset( &set, SIGINT ); /* Add SIGINT to it */
sigprocmask( SIG_BLOCK, &set, &previous ); /* Add SIGINT to the mask */
/* SIGINT is blocked in this section */
sigprocmask( SIG_SETMASK, &previous, NULL ); /* Restore previous mask */
```
5. **Signal handler**: "for signal X, run function foo"
    - we can only use functions that are **reentrant** (no pritf, malloc, free, or anything blocking)
    - signal handler needs to be **async-signal safe**
```c
void (*signal( int signo, void (*handler)(int))) (int);
/* signal handler */
void sig_handler( int signal_num ) {
    /* Handle signal here */
}
signal( SIGNINT, sig_handler );
```
6. **Message passing with queues**
    - **Indirect communication**: messages are sent to queues owned by the operating system
    - when message queue is full, we can (3): wait (block); overwrite older message; discard the current message
    - get a key: `key_t ftok( char *pathname, int proj );` or `IPC_PRIVATE`
```c
/* get the message queue */
int msgget( key_t key, int flag );
/* nbyte: size of the data
   flag: what happens when the queue is full; 0 (blocking) and IPC_NOWAIT */
int msgsnd( int msqid, const void *ptr, size_t nbytes, int flag );
/* ptr: where the data is copied to 
   type: the type of message you want
   (1) == 0  first message of any type
   (2) > 0   first message with a specified type
   (3) < 0   first message on the queue whose type is smaller or equal to |type| */
ssize_t msgrcv( int msqid, void *ptr, size_t nbytes, long type, int flag );
/* command: IPC_RMID; * buf: NULL */
int msgctl( int msqid, int command, struct msqid_ds * buf );

struct msg {
    long mtype;
    int data;
};
int main( int argc, char** argv ) {
    int msgqid = msgget( IPC_PRIVATE, 0666 | IPC_CREAT );
    int pid = fork();
    if ( pid > 0 ) { /* Parent */
        struct msg m;
        m.mtype = 42;
        m.data = 252;
        msgsnd( msgqid, &m, sizeof( int ), 0 );
    } else if ( pid == 0 ) { /* Child */
        struct msg m2;
        msgrcv( msgqid, &m2, sizeof( int ), 42, 0 );
        printf("Received %d!\n", m2.data );
        msgctl( msgqid, IPC_RMID, NULL );
    }
    return 0;
}
```
## Network Communication
1. Idea: how to communicate over the network in a standard way; estabilish communication between two processes
2. **Datagram**: like sending mail; no connection is established; unidirectional
3. **Stream**: like making telephone call
```c
/* domain: the address format (IPv4 AF_INET, Ipv6, and more)
   type: SOCK_DGRAM; SOCK_STREAM 
   protocol: 0 fro the default (stream: TCP/IP; datagram: UDP) */
int socket( int domain, int type, int protocol );
```
4. **Check number format**: there are two possible (reasonable) orders for how its bytes can be stored: smallest to largest or largest to smallest. `arpa/inet.h` can help with the translation.
```c
uint32_t htonl( uint32_t hostint32 ); /* Translate 4 byte int to network format */
uint16_t htons( uint16_t hostint16 ); /* Translate 2 byte int to network format */
uint32_t ntohl( uint32_t netint32 ); /* Translate 4 byte int to host format */
uint16_t ntohs( uint16_t netint16 ); /* Translate 2 byte int to host format */
```
5. **Address**: we want to call someone, we need to put in their phone numbers
```c
struct sockaddr_in {
    sa_family_t sin_family; /* Address family */
    in_port_t sin_port; /* Port number */
    struct in_addr sin_addr; /* IPv4 Address */
};

struct sockaddr_in addr;
addr.sin_family = AF_INET; /* IPv4 */
addr.sin_port = htons( 2520 );
addr.sin_addr.s_addr = htonl( INADDR_ANY ); /* Current IP address of the current comp */
```
6. Ports: below 1024 (reserved for system services); 22 (ssh); 80 (HTTP)
7. Looking up addresses by name
```c
int getaddrinfo(const char *node, /* e.g. "www.example.com" or IP */
                const char *service, /* e.g. "http" or port number */
                const struct addrinfo *hints,
                struct addrinfo **res); /* info will be returned in res*/

struct addrinfo hints;
struct addrinfo *res; /* will point to the results
43 */
memset(&hints, 0, sizeof hints); /* make sure the struct is empty */
hints.ai_family = AF_INET; /* Choose IPv4 */
hints.ai_socktype = SOCK_STREAM; /* TCP stream sockets */
hints.ai_flags = AI_PASSIVE; /* fill in my IP for me */
int result = getaddrinfo("www.example.com", "2520", &hints, &res);
if (result != 0) {
    return -1;
}
struct sockaddr_in * sain = (struct sockaddr_in*) res->ai_addr; /* the actual info linked list */
freeaddrinfo( res );
```
8. **Client: Connect**
```c
int connect( int sockfd, struct sockaddr *addr, socklen_t len);

getaddrinfo("www.uwaterloo.ca", "80", &hints, &res);
sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
int status = connect(sockfd, res->ai_addr, res->ai_addrlen);
```
9. **Server: Bind, Listen, and Accept**
    - bind (got a phone number): associate the socket with the port
    - listen (phone turned on): wait for incoming connections
    - accept (press the green icon)
```c
/* backlog is a upper bound for number of connections, 
   if the queue is full, we reject additional requests */
int listen( int sockfd, int backlog );
/* returns a new socket file descriptor where further communication takes palce */
int accept( int sockfd, struct sockaddr *addr, socklen_t *len );

bind( socketfd, (struct sockaddr*) &addr, sizeof( addr ) );
listen( socketfd, 5 );
int newsockfd = accept( socketfd, NULL, NULL );
/* Do something */

close( newsockfd );
close( socketfd );
```
10. [TODO]

## Pipes and Shared Memory
1. **Pipe**: unidirectional communication between a producer and a consumer
    - sender placed the message in small chunks while the receiver reads one character at a time
    - A **named pipe** is a pipe stored on disk. It exists even when the creating process has terminated. It is bidirectional (communication happens one direction at a time).
```c
/* fileDescriptors[0]: read-end; fileDescriptor[1]: write-end */
pipe( int fileDescriptors[] );

int main( int argc, char** argv ) {
    char write_msg[BUFFER_SIZE] = "Greetings";
    char read_msg[BUFFER_SIZE];
    int fd[2];
    pid_t pid;
    if (pipe(fd) == -1) {
        fprintf(stderr,"Pipe failed");
        return 1;
    }
    pid = fork();
    if (pid < 0) { /* error occurred */
        fprintf(stderr, "Fork Failed");
        return 1;
    }
    if (pid > 0) { /* parent process */
        close(fd[READ_END]);
        write(fd[WRITE_END], write_msg, strlen(write_msg));
        close(fd[WRITE_END]);
    } else { /* child process */
        close(fd[WRITE_END]);
        read(fd[READ_END], read_msg, BUFFER_SIZE);
        printf("read %s",read_msg);
        close(fd[READ_END]);
    }
    return 0;
}
```
2. **Shared Memory** with `sys/shm.h.`
```c
/* create a new shared memory segment */
int shmget( key_t key, size_t size, int shmflg );
/* attach the shared memory segment */
void* shmat( int shmid, const void* shmaddr, int shmflg );
/* detach the shared memory segment */
int shmdt( const void* shmaddr );
/* delete the shared memory segment */ 
int shmctl( int shmid, int cmd, struct shmid_ds *buf );

int main( int argc, char** argv ) {
    int shmid = shmget( IPC_PRIVATE, 32, IPC_CREAT | 0666 );
    int pid = fork();
    if ( pid > 0 ) { /* Parent */
        waitpid( pid, NULL, 0 );
        void* mem = shmat( shmid, NULL, 0 );
        printf("The message the parent received from the child is %s.\n", (char*) mem );
        shmdt( mem );
        shmctl( shmid, IPC_RMID, NULL );
    } else if ( pid == 0 ) { /* Child */
        void* mem = shmat( shmid, NULL, 0 );
        memset( mem, 0, 32 );
        sprintf( mem, "Hello World" );
        shmdt( mem );
    }
    return 0;
}
```
3. **Shared Memory with** `mmap` (map a file into memory)
```c
/* NULL for address so that the system would decide
   protection: PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXECUTE
   (PROT_NONE can be used to guard a region of memory.)
   flag: MAP_PRIVATE (changes not written out to the underlying file), MAP_SHARED */
void* mmap( void* address, size_t length, int protection, int flag, int fd, off_t offset );
/* change protection rules */
int mprotect( void* address, size_t length, int prot );
int msync( void* address, size_t length, int flags );
int munmap( void* address, size_t length );

int main( int argc, char** argv ) {
    int fd = open( "example.txt", O_RDWR );
    struct stat st;
    stat( "example.txt", &st );
    ssize_t size = st.st_size; /* size of the memory shared is hard to change */
    void* mapped = mmap( NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0 );
    int pid = fork();
    if ( pid > 0 ) { /* Parent */
        waitpid( pid, NULL, 0 );
        printf("The new content of the file is: %s.\n", (char*) mapped);
        munmap( mapped, size );
    } else if ( pid == 0 ) { /* Child */
        memset( mapped, 0, size ); /* Erase what’s there */
        sprintf( mapped, "It is now Overwritten");
        /* Ensure data is synchronized */
        msync( mapped, size, MS_SYNC );
        munmap( mapped, size );
    }
    close( fd );
    return 0;
}
```
